import snakemake
import os

"""
export SUBJECTS_DIR=~/hdd/data/neuroimaging/freesurfer_output/

A snakemake file for running reconstructions on the neuroimaging data.

snakemake --dag | dot -Tpdf > dag_neuroimaging_pipeline_reconstruction.pdf

Runs tests to ensure data is all in the corresponding format:

0. patient (raw)
    - premri
        - (list) dicoms
    - postct
        - (list) dicoms
    - dti
        - (list) dicoms

0b. freesurfer_output / reconstruction_output
    - patient (reconstruction)
        - (tree) files
    - finaloutput_datadir (stores all files we want to use in the next step)
    - success_file_flag.txt
    - stick all raw file

1. patient (processed)
    - mri
        - nifti volume image
    - ct
        - nifti volume image
    - dti (optional)
        - nifti volume image
    - elec
        - ct_in_t1_volume image
        - chans_xyz.txt
    - surface (how to draw out the brain; )
        - triangles.txt
        - vertices.txt
        - normals.txt
        - voxel_xyz.txt
    - parcellation (depends on atlas)
        -<atlas_1>
            - region_mapping_cort_<atlas>.txt
            - region_mapping_subcort_<atlas>.txt
            - region_centres_<atlas>.txt
            - region_areas_<atlas>.txt
            - region_cortical_<atlas>.txt
            - region_average_orientations_<atlas>.txt
            - label_in_T1_<atlas> volume image (maps all voxels to an atlas region)
    - connectome (depends on atlas)
        - tract_lengths_<atlas>.txt
        - weights_<atlas>.txt
        - gain_mat_<atlas>.txt (how to project regional activity -> sensor space | mainly for TVB)
    - seeg
        - edf
        - fif
    - scalp
        - edf
        - fif
    - clinical
        - ez_hypothesis_chans.txt
        - ez_hypothesis_<atlas>.txt
        - stores clinical metadata
        - PPTs related
    TUTORIAL_FILE.TXT

If this doesn't work off the bat, make sure you explicitly set SUBJECTS_DIR
"""
configfile: "../config/localconfig.yaml"
# snakemake.utils.validate(config, "../config/preformat_config.schema.yaml")

# os.putenv('SUBJECTS_DIR', config['fs_outputdatadir']); os.system('bash')"

# get the environment variable for freesurfer - for use in getting access to lut's
FREESURFER_HOME = os.getenv("FREESURFER_HOME") or ''
MRTRIX3_HOME = os.getenv("MRTRIX3_HOME") or ''
HOME_DIR="../../"
SCRIPTS_UTIL_DIR = "../neuroimg/format/"
ATLAS=['dk', 'destrieux']

''' USER DEFINED DIRECTORIES TO STORE FINAL DATA IN ORGANIZED SUBFOLDERS '''
FS_PATIENT_OUTPUT_DIR = os.path.join(config['fs_outputdatadir'],
                                     "{patient_id}")

PATIENT_OUTPUT_DIR = os.path.join(config['finaloutput_datadir'],
                                        "{patient_id}")

parc = "aparc.a2009s"
aa = "aparc+aseg"
sval = "pial"
hemispheres = ['lh', 'rh']
resamp_target = "fsaverage5"

# print(config['patients'])

# First rule
rule all:
    input:
        # CT_NIFTI_IMG=expand(os.path.join(config['fs_outputdatadir'], "{patient_id}", "CT",
        #                                  "CT.nii"), patient_id=config['patients']),
        # lhpial = expand(os.path.join(FS_PATIENT_OUTPUT_DIR, "surf", "ascii",
        #                       "lh.pial.asc"),
        #                 patient_id=config['patients']),
        # brainmask_nifti = expand(os.path.join(FS_PATIENT_OUTPUT_DIR, "mri",
        #                        "brainmask.nii.gz"), patient_id=config['patients']),
        outsuccess_file=expand(os.path.join(config['fs_outputdatadir'],
                                "{patient_id}_recon_success.txt"),  patient_id=config['patients']),
    shell:
        "echo 'done'"


"""
Rule for prepping fs_recon.

The purpose is to setup a directory file structure that plays nice w/ Freesurfer. If you are using
some other module it is recommended to just add directories in there.

Rule for converting .dicom -> .niftiPUT_DIR,
                            "lh.native.aparc.annot"),
        rhlabel=os.path.join(NATIVESPACE_OUTPUT_DIR,
                            "rh.native.aparc.annot"),

Assumes user has premri and postct with DTI being optional, as this is not standard clinical procedure
in the USA.

"""
rule prep_recon:
    params:
        fs_subj_dir = os.path.join(config['fs_outputdatadir'], "{patient_id}"),
        CT_FOLDER=os.path.join(config['rawdatadir'],"{patient_id}", "postct"),
        MRI_FOLDER=os.path.join(config['rawdatadir'], "{patient_id}", "premri"),
        CTDIR = os.path.join(config['fs_outputdatadir'], "{patient_id}", "CT"),
        elecsdir = os.path.join(config['fs_outputdatadir'], "{patient_id}", "elecs"),
        acpcdir = os.path.join(config['fs_outputdatadir'], "{patient_id}", "acpc"),
    output:
        CT_NIFTI_IMG=os.path.join(config['fs_outputdatadir'], "{patient_id}", "CT",
                                         "CT.nii"),
        MRI_MGZ_IMG=os.path.join(config['fs_outputdatadir'], "{patient_id}", "mri", "orig",
                                                        "001.mgz"),
        MRI_NIFTI_IMG = os.path.join(config['fs_outputdatadir'], "{patient_id}", "mri",
                                                    "T1.nii")
    shell:
        # "mkdir {params.fs_subj_dir};"
        "mkdir -p {params.CTDIR};"
        "mkdir -p {params.elecsdir};"
        "mkdir -p {params.acpcdir};"
        "mrconvert {params.MRI_FOLDER} {output.MRI_MGZ_IMG};"
        "mrconvert {params.CT_FOLDER} {output.CT_NIFTI_IMG};"
        "mrconvert {output.MRI_MGZ_IMG} {output.MRI_NIFTI_IMG};"

"""
Rule to run more then one MRI/CT Scan for Movement Correction
"""
rule add_scans_for_subj:
    params:
        fs_subj_dir = os.path.join(config['fs_outputdatadir'], "{patient_id}"),
        MRI_FOLDER=os.path.join(config['rawdatadir'], "{patient_id}", "premri2"),
        MRI1_NIFTI_IMG = os.path.join(config['fs_outputdatadir'], "{patient_id}", "mri",
                                                    "T1.nii")
    output:
        MRI_MGZ_IMG=os.path.join(config['fs_outputdatadir'], "{patient_id}", "mri", "orig",
                                                        "002.mgz"),
        MRI_NIFTI_IMG = os.path.join(config['fs_outputdatadir'], "{patient_id}", "mri",
                                                    "T1_2.nii"),
        MRI_CONFORMED_NIFTI_IMG = os.path.join(FS_PATIENT_OUTPUT_DIR, "mri", "T1_2conform.nii.gz")
    shell:
        "mrconvert {params.MRI_FOLDER} {output.MRI_NIFTI_IMG};"
        "flirt -in {output.MRI_NIFTI_IMG} -ref {params.MRI1_NIFTI_IMG} -out {output.MRI_CONFORMED_NIFTI_IMG};"
        "mrconvert {output.MRI_CONFORMED_NIFTI_IMG} {output.MRI_MGZ_IMG};"

"""
Rule for reconstructions .nifti -> output files.

Since Freesurfer creates the directory on its own + snakemake does too,
I instead specify an output as a "temporary" flagger file that will let snakemake
know that reconstruction was completed.
"""
rule reconstruction:
    input:
        MRI2_MGZ_IMG=os.path.join(config['fs_outputdatadir'], "{patient_id}", "mri", "orig",
                                                        "002.mgz"),
        MRI_MGZ_IMG = os.path.join(config['fs_outputdatadir'], "{patient_id}", "mri", "orig",
                           "001.mgz"),
    params:
        patient="{patient_id}",
        SUBJECTS_DIR=os.path.join(config['fs_outputdatadir']),
    output:
        outsuccess_file=os.path.join(config['fs_outputdatadir'],
                                "{patient_id}_recon_success.txt")
    shell:
        "export SUBJECTS_DIR={params.SUBJECTS_DIR}; \
            SUBJECTS_DIR={params.SUBJECTS_DIR};"
        "recon-all " \
            # "-i {input.MRI_MGZ_IMG} " \
            "-subjid {params.patient} -all "\
            "-parallel -openmp 4;"
        "touch {output.outsuccess_file}"

"""
Rule for converting the pial surfaces to ascii data, so that it is readable by python/matlab.
"""
rule convert_pial_surface_files_ascii:
    input:
        outsuccess_file=os.path.join(config['fs_outputdatadir'],
                                "{patient_id}_recon_success.txt")
    params:
        lhpial = os.path.join(FS_PATIENT_OUTPUT_DIR, "surf",
                              "lh.pial"),
        rhpial = os.path.join(FS_PATIENT_OUTPUT_DIR, "surf",
                              "rh.pial"),
    output:
        lhpial=os.path.join(FS_PATIENT_OUTPUT_DIR, "surf", "ascii",
                            "lh.pial.asc"),
        rhpial=os.path.join(FS_PATIENT_OUTPUT_DIR, "surf", "ascii",
                            "rh.pial.asc"),
    shell:
        "mris_convert {params.lhpial} {output.lhpial};"
        "mris_convert {params.rhpial} {output.rhpial};"

"""
Rule for converting brainmask image volume to Nifti
"""
rule convert_brainmask_to_nifti:
    input:
        outsuccess_file = os.path.join(config['fs_outputdatadir'],
                               "{patient_id}_recon_success.txt")
    params:
        brainmask_mgz = os.path.join(FS_PATIENT_OUTPUT_DIR, "mri",
                                     "brainmask.mgz")
    output:
        brainmask_nifti = os.path.join(FS_PATIENT_OUTPUT_DIR, "mri",
                                       "brainmask.nii.gz")
    shell:
        "mri_convert {params.brainmask_mgz} {output.brainmask_nifti};"

# """
# Rule to copy all necessary reconstruction files to a temporary directory,
# so that we can explicitly say which files are being analyzed/used.
#
# Add here files to copy them to the directory that we allow scripts to draw from.
# """
# rule copy_reconstruction_files:
#     input:
#         outsuccess_file=os.path.join(config['fs_outputdatadir'],
#                                 "{patient_id}_recon_success.txt")
#     params:
#         lhpial=os.path.join(config['fs_outputdatadir'],
#                             "{patient_id}",
#                             "surf/lh.pial"),
#         rhpial=os.path.join(config['fs_outputdatadir'],
#                             "{patient_id}",
#                             "surf/rh.pial"),
#         lhlabel=os.path.join(config['fs_outputdatadir'],
#                             "{patient_id}",
#                             "label/lh.aparc.annot"),
#         rhlabel=os.path.join(config['fs_outputdatadir'],
#                             "{patient_id}",
#                             "label/rh.aparc.annot"),
#         aseg_output_file = os.path.join(config['fs_outputdatadir'],
#                                         "{patient_id}",
#                                         "mri/aseg.mgz"),
#         norm_output_file = os.path.join(config['fs_outputdatadir'],
#                                         "{patient_id}",
#                                         "mri/norm.mgz"),
#         aparc_dkatlas_aseg_file = os.path.join(config['fs_outputdatadir'],
#                                                  "{patient_id}",
#                                                 "mri/aparc+aseg.mgz"),
#         aparc_atlas_aseg_file = os.path.join(config['fs_outputdatadir'],
#                                                  "{patient_id}",
#                                                 "mri/aparc.a2009s+aseg.mgz"),
#         t1_mgz_file = os.path.join(config['fs_outputdatadir'],
#                         "{patient_id}",
#                         "mri/T1.mgz"),
#         brainmask_file = os.path.join(config['fs_outputdatadir'],
#                                       "{patient_id}",
#                                       "mri/brainmask.mgz"),
#         rawavg_file = os.path.join(config['fs_outputdatadir'],
#                                       "{patient_id}",
#                                       "mri/rawavg.mgz"),
#         wm_output_file = os.path.join(config['fs_outputdatadir'],
#                                       "{patient_id}",
#                                       "mri/wm.mgz"),
#         talairach_transform_file = os.path.join(config['fs_outputdatadir'],
#                                                 "{patient_id}",
#                                                 "mri/transforms/talairach.xfm")
#     output:
#         lhpial=os.path.join(PATIENT_OUTPUT_DIR,
#                             "lh.pial"),
#         rhpial=os.path.join(PATIENT_OUTPUT_DIR,
#                             "rh.pial"),
#         lhlabel=os.path.join(PATIENT_OUTPUT_DIR,
#                             "lh.aparc.annot"),
#         rhlabel=os.path.join(PATIENT_OUTPUT_DIR,
#                             "rh.aparc.annot"),
#         aseg_output_file = os.path.join(PATIENT_OUTPUT_DIR,
#                                         "aseg.mgz"),
#         norm_output_file = os.path.join(PATIENT_OUTPUT_DIR,
#                                         "norm.mgz"),
#         aparc_atlas_aseg_file = os.path.join(PATIENT_OUTPUT_DIR,
#                                              "aparc.a2009s+aseg.mgz"),
#         aparc_dkatlas_aseg_file = os.path.join(PATIENT_OUTPUT_DIR,
#                                             "aparc+aseg.mgz"),
#         t1_mgz_file = os.path.join(PATIENT_OUTPUT_DIR,
#                                         "T1.mgz"),
#         brainmask_file = os.path.join(PATIENT_OUTPUT_DIR,
#                                       "brainmask.mgz"),
#         wm_output_file = os.path.join(PATIENT_OUTPUT_DIR,
#                                       "wm.mgz"),
#         rawavg_file = os.path.join(PATIENT_OUTPUT_DIR,
#                                    "rawavg.mgz"),
#         talairach_transform_file = os.path.join(PATIENT_OUTPUT_DIR,
#                                                 "transforms/talairach.xfm")
#     shell:
#         "cp {params.lhpial} {output.lhpial};"
#         "cp {params.rhpial} {output.rhpial};"
#         "cp {params.lhlabel} {output.lhlabel};"
#         "cp {params.rhlabel} {output.rhlabel};"
#         "cp {params.aseg_output_file} {output.aseg_output_file};"
#         "cp {params.norm_output_file} {output.norm_output_file};"
#         "cp {params.aparc_atlas_aseg_file} {output.aparc_atlas_aseg_file};"
#         "cp {params.aparc_dkatlas_aseg_file} {output.aparc_dkatlas_aseg_file};"
#         "cp {params.t1_mgz_file} {output.t1_mgz_file};"
#
#         "cp {params.brainmask_file} {output.brainmask_file};"
#         "cp {params.rawavg_file} {output.rawavg_file};"
#         "cp {params.wm_output_file} {output.wm_output_file};"
#
#         "cp {params.talairach_transform_file} {output.talairach_transform_file};"
