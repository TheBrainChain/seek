import os
import sys
from pathlib import Path
from mne_bids import make_bids_basename

sys.path.append("../../../")
from neuroimg.pipeline.fileutils import SCRIPTS_UTIL_DIR
from neuroimg.pipeline.fileutils import BidsRoot, BIDS_ROOT

"""
export SUBJECTS_DIR=~/hdd/data/neuroimaging/freesurfer_output/

A snakemake file for running reconstructions on the neuroimaging data.

snakemake --dag | dot -Tpdf > dag_pipeline_reconstruction.pdf

Runs tests to ensure data is all in the corresponding format: BIDS iEEG

If this doesn't work off the bat, make sure you explicitly set SUBJECTS_DIR
"""
configfile: "/neuroimg/pipeline/config/localconfig.yaml"

# get the freesurfer patient directory
bids_root = BidsRoot(BIDS_ROOT(os.environ['bids_root']))
subject_wildcard = "{subject}"

# initialize directories that we access in this snakemake
FS_DIR = bids_root.freesurfer_dir
FSPATIENT_SUBJECT_DIR = bids_root.get_freesurfer_patient_dir(subject_wildcard)
FSOUT_MRI_FOLDER = Path(FSPATIENT_SUBJECT_DIR / "mri")
FSOUT_CT_FOLDER = Path(FSPATIENT_SUBJECT_DIR / "CT")
FSOUT_ELECS_FOLDER = Path(FSPATIENT_SUBJECT_DIR / "elecs")
FSOUT_ACPC_FOLDER = Path(FSPATIENT_SUBJECT_DIR / "acpc")
FSOUT_SURF_FOLDER = Path(FSPATIENT_SUBJECT_DIR / "surf")


session = 'veeg'
def _get_bids_basename(subject, imgtype):
    """Wildcard function to get bids_basename."""
    bids_fname = make_bids_basename(subject,
                                    session=session,
                                    suffix=f"{imgtype}.nii.gz")
    return bids_fname

def _get_subject_dir(bids_root, subject):
    return os.path.join(bids_root, f"sub-{subject}")

def _get_anat_bids_dir(bids_root, subject):
    return os.path.join(_get_subject_dir(bids_root, subject), f'ses-{session}', 'anat')


subworkflow prep_workflow:
    workdir:
        "../01-prep/"
    snakefile:
        "../01-prep/Snakefile"
    configfile:
        "/neuroimg/pipeline/config/localconfig.yaml"

# First rule
rule all:
    input:
        outsuccess_file=expand(os.path.join(FSPATIENT_SUBJECT_DIR, "{subject}_recon_success.txt"),
                               subject=config['patients']),
        brainmask_nifti = expand(os.path.join(FSOUT_MRI_FOLDER, "brainmask.nii.gz"),
                               subject=config['patients']),
        # lhpial = expand(os.path.join(FSOUT_SURF_FOLDER, "ascii", "lh.pial.asc"),
        #                         subject=config['patients']),
        # rhpial = expand(os.path.join(FSOUT_SURF_FOLDER, "ascii", "rh.pial.asc"),
        #                         subject=config['patients']),
        subcort_success_flag_file = expand(os.path.join(FSPATIENT_SUBJECT_DIR, "{subject}_subcort_success.txt"),
                                subject=config['patients']),
    shell:
        "echo 'done'"


"""
Rule for prepping fs_recon.

The purpose is to setup a directory file structure that plays nice w/ Freesurfer. If you are using
some other module it is recommended to just add directories in there.

Rule for converting .dicom -> .niftiPUT_DIR,
                            "lh.native.aparc.annot"),
        rhlabel=os.path.join(NATIVESPACE_OUTPUT_DIR,
                            "rh.native.aparc.annot"),

"""
rule prep_recon:
    input:
        CT_NIFTI_IMG = prep_workflow(os.path.join(_get_anat_bids_dir(bids_root.bids_root, subject_wildcard),
                                     _get_bids_basename(subject_wildcard, imgtype='CT'))),
        MRI_NIFTI_IMG = prep_workflow(os.path.join(_get_anat_bids_dir(bids_root.bids_root, subject_wildcard),
                                    _get_bids_basename(subject_wildcard, imgtype='T1w'))),
    params:
        CTDIR = FSOUT_CT_FOLDER,
        elecsdir = FSOUT_ELECS_FOLDER,
        acpcdir = FSOUT_ACPC_FOLDER,
        INPUT_FS_ORIG_DIR = os.path.join(FSOUT_MRI_FOLDER, "orig"),
    output:
        MRI_MGZ_IMG=os.path.join(FSOUT_MRI_FOLDER, "orig", "001.mgz"),
        CT_NIFTI_IMG=os.path.join(FSOUT_CT_FOLDER, "CT.nii"),
    shell:
        "mkdir -p {params.CTDIR};"
        "mkdir -p {params.elecsdir};"
        "mkdir -p {params.acpcdir};"
        "mkdir -p {params.INPUT_FS_ORIG_DIR};"
        "mri_convert {input.CT_NIFTI_IMG} {output.CT_NIFTI_IMG};"
        "mri_convert {input.MRI_NIFTI_IMG} {output.MRI_MGZ_IMG};"


"""
Use ACPC aligned T1 image. Comment out if not using.
"""
# rule use_acpc_specified_input:
#     params:
#         ACPC_IMAGE = os.path.join(RAW_MRIACPC_FOLDER, "{subject}_MR_acpc.nii"),
#     output:
#         FS_ACPC_IMAGE = os.path.join(FSOUT_ACPC_FOLDER, "{subject}_MR_acpc.nii"),
#         MRI_MGZ_IMG = os.path.join(FSOUT_MRI_FOLDER, "orig", "001.mgz"),
#     shell:
#         "cp {params.ACPC_IMAGE} {output.FS_ACPC_IMAGE};"
#         "mri_convert {input.FS_ACPC_IMAGE} {output.MRI_MGZ_IMG};"


"""
TODO: Rule to run more then one MRI/CT Scan for Movement Correction.

Converts another folder into more scans. WIP.
"""
# rule add_scans_for_subj:
#     params:
#         fs_subj_dir = FS_PATIENT_OUTPUT_DIR,
#         MRI_FOLDER=os.path.join(FS_PATIENT_OUTPUT_DIR, "premri2"),
#         MRI1_NIFTI_IMG = os.path.join(FSOUT_MRI_FOLDER, "T1.nii")
#     output:
#         MRI_MGZ_IMG=os.path.join(FSOUT_MRI_FOLDER, "orig", "002.mgz"),
#         MRI_NIFTI_IMG = os.path.join(FSOUT_MRI_FOLDER, "origT1_2.nii"),
#         MRI_CONFORMED_NIFTI_IMG = os.path.join(FS_PATIENT_OUTPUT_DIR, "mri", "T1_2conform.nii.gz")
#     shell:
#         "mri_convert {params.MRI_FOLDER} {output.MRI_NIFTI_IMG};"
#         "flirt -in {output.MRI_NIFTI_IMG} -ref {params.MRI1_NIFTI_IMG} -out {output.MRI_CONFORMED_NIFTI_IMG};"
#         "mri_convert {output.MRI_CONFORMED_NIFTI_IMG} {output.MRI_MGZ_IMG};"


"""
Rule for reconstructions .nifti -> output files.

Since Freesurfer creates the directory on its own + snakemake does too,
I instead specify an output as a "temporary" flagger file that will let snakemake
know that reconstruction was completed.
"""
rule reconstruction:
    input:
        MRI_MGZ_IMG = os.path.join(FSOUT_MRI_FOLDER, "orig", "001.mgz"),
    params:
        patient=subject_wildcard,
        SUBJECTS_DIR=FS_DIR,
    output:
        outsuccess_file=os.path.join(FSPATIENT_SUBJECT_DIR, "{subject}_recon_success.txt")
    shell:
        "export SUBJECTS_DIR={params.SUBJECTS_DIR};" \
        "SUBJECTS_DIR={params.SUBJECTS_DIR};"
        "recon-all " \
            "-cw256 " \
            # "-i {input.MRI_MGZ_IMG} " \
            "-subject {params.patient} " \
            "-all "\
            "-parallel -openmp $(nproc);"
        "touch {output.outsuccess_file}"

"""
Rule for converting the pial surfaces to ascii data, so that it is readable by python/matlab.
"""
# rule convert_pial_surface_files_ascii:
#     input:
#         recon_success_file=os.path.join(FSPATIENT_SUBJECT_DIR, "{subject}_recon_success.txt")
#     params:
#         lhpial = os.path.join(FSOUT_SURF_FOLDER, "lh.pial"),
#         rhpial = os.path.join(FSOUT_SURF_FOLDER, "rh.pial"),
#     output:
#         lhpial=os.path.join(FSOUT_SURF_FOLDER, "ascii", "lh.pial.asc"),
#         rhpial=os.path.join(FSOUT_SURF_FOLDER, "ascii", "rh.pial.asc"),
#     shell:
#         "mris_convert {params.lhpial} {output.lhpial};"
#         "mris_convert {params.rhpial} {output.rhpial};"


"""
Rule for converting the pial surfaces to ascii data, so that it is readable by python/matlab.
"""
# rule convert_freesurfer_T1_to_nifti:
#     input:
#         recon_success_file=os.path.join(FSPATIENT_SUBJECT_DIR, "{subject}_recon_success.txt")
#     params:
#         lhpial = os.path.join(FSOUT_SURF_FOLDER, "lh.pial"),
#         rhpial = os.path.join(FSOUT_SURF_FOLDER, "rh.pial"),
#     output:
#         lhpial=os.path.join(FSOUT_SURF_FOLDER, "ascii", "lh.pial.asc"),
#         rhpial=os.path.join(FSOUT_SURF_FOLDER, "ascii", "rh.pial.asc"),
#     shell:
#         "mris_convert {params.lhpial} {output.lhpial};"
#         "mris_convert {params.rhpial} {output.rhpial};"


rule convert_FS_T1_to_nifti:
    input:
        recon_success_file=os.path.join(FSPATIENT_SUBJECT_DIR, "{subject}_recon_success.txt")
    params:
        PREMRI_MGZ_IMG = os.path.join(FSOUT_MRI_FOLDER, "T1.mgz"),
    output:
        PREMRI_NIFTI_IMG = os.path.join(FSOUT_MRI_FOLDER, "T1.nii"),
    shell:
        "mri_convert {params.PREMRI_MGZ_IMG} {output.PREMRI_NIFTI_IMG};"


"""
Rule for converting brainmask image volume from MGZ to Nifti.
"""
rule convert_brainmask_to_nifti:
    input:
        recon_success_file = os.path.join(FSPATIENT_SUBJECT_DIR, "{subject}_recon_success.txt")
    params:
        brainmask_mgz = os.path.join(FSOUT_MRI_FOLDER, "brainmask.mgz")
    output:
        brainmask_nifti = os.path.join(FSOUT_MRI_FOLDER, "brainmask.nii.gz")
    shell:
        "mri_convert {params.brainmask_mgz} {output.brainmask_nifti};"

"""
Rule for extracting the subcortical regions

- creates a new folder aseg2srf inside the fs_output data directory
- c/p this into our final result directory
"""
rule create_subcortical_volume:
    input:
        outsuccess_file = os.path.join(FSPATIENT_SUBJECT_DIR, "{subject}_recon_success.txt")
    params:
        SUBJECTS_DIR = FS_DIR,
        patient="{subject}",
        scripts_dir=SCRIPTS_UTIL_DIR,
    output:
        subcort_success_flag_file=os.path.join(FSPATIENT_SUBJECT_DIR, "{subject}_subcort_success.txt"),
    shell:
        # generate subcortical region volume bounding surfaces
        "export SUBJECTS_DIR={params.SUBJECTS_DIR};"
        "SUBJECTS_DIR={params.SUBJECTS_DIR};"
        "{params.scripts_dir}/aseg2srf -s {params.patient};"
        "touch {output.subcort_success_flag_file};"


