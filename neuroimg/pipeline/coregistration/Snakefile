import os


"""
export SUBJECTS_DIR=~/hdd/data/neuroimaging/freesurfer_output/

A snakemake file for running reconstructions on the neuroimaging data.

snakemake --dag | dot -Tpdf > dag_neuroimaging_pipeline_coregistration.pdf

"""
configfile: "../config/localconfig.yaml"

# get the environment variable for freesurfer - for use in getting access to lut's
FREESURFER_HOME = os.getenv("FREESURFER_HOME") or ''
MRTRIX3_HOME = os.getenv("MRTRIX3_HOME") or ''
HOME_DIR="../../"
SCRIPTS_UTIL_DIR = "../neuroimg/format/"
ATLAS=['dk', 'destrieux']

''' USER DEFINED DIRECTORIES TO STORE FINAL DATA IN ORGANIZED SUBFOLDERS '''
FS_PATIENT_OUTPUT_DIR = os.path.join(config['fs_outputdatadir'],
                                     "{patient_id}")

COREGISTRATION_OUTPUT_DIR = os.path.join(config['fs_outputdatadir'],
                                         "{patient_id}",
                                         "CT")

parc = "aparc.a2009s"
aa = "aparc+aseg"
sval = "pial"
hemispheres = ['lh', 'rh']
resamp_target = "fsaverage5"

subworkflow reconstruction_workflow:
    workdir:
        "../reconstruction/"
    snakefile:
        "../reconstruction/Snakefile"
    configfile:
        "../config/localconfig.yaml"

# First rule
rule all:
    input:
        # FLIRT FSL OUTPUT COREGISTRATION
        CT_IN_T1_NIFTI_IMG_ORIG=expand(os.path.join(COREGISTRATION_OUTPUT_DIR,
                                               "rCT.nii.gz"),
                                         patient_id=config['patients']),
        # mapping matrix for CT to T1
        MAPPING_FILE=expand(os.path.join(COREGISTRATION_OUTPUT_DIR,
                                        "fsl_ct-to-t1_omat.txt"),
                                    patient_id=config['patients']),

        # MAPPED BRAIN MASK TO CT SPACE
        brainmask_inct_file = expand(os.path.join(COREGISTRATION_OUTPUT_DIR,
                                                     "brainmask_inct.nii.gz"),
                                    patient_id=config['patients']),

        wm_inct_outputfile_nifti = expand(os.path.join(COREGISTRATION_OUTPUT_DIR,
                                        "wm_in_ct.nii"), patient_id=config['patients']),

    shell:
        "echo 'done'"


"""
Rule for coregistering .nifit images -> .nifti for T1 space

E.g. useful for CT, and DTI images to be coregistered
"""
rule coregistert1_ct_to_pre:
    input:
        PREMRI_NIFTI_IMG_MGZ = os.path.join(FS_PATIENT_OUTPUT_DIR, "mri",
                                            "T1.nii"),
        CT_NIFTI_IMG_MGZ = os.path.join(FS_PATIENT_OUTPUT_DIR, "CT",
                                             "CT.nii"),
    output:
        # mapped image from CT -> MRI
        CT_IN_PRE_NIFTI_IMG_ORIGgz = os.path.join(COREGISTRATION_OUTPUT_DIR,
                                                      "rCT.nii.gz"),
        # mapping matrix for post to pre in T1
        MAPPING_FILE_ORIG = os.path.join(COREGISTRATION_OUTPUT_DIR,
                                    "fsl_ct-to-t1_omat.txt"),
    shell:
        "flirt -in {input.CT_NIFTI_IMG_MGZ} \
                            -ref {input.PREMRI_NIFTI_IMG_MGZ} \
                            -omat {output.MAPPING_FILE_ORIG} \
                            -out {output.CT_IN_PRE_NIFTI_IMG_ORIGgz};"



"""
Rule for converting brainmask image volume to Nifti
"""
rule convert_brainmask_to_nifti:
    input:
        outsuccess_file = os.path.join(config['fs_outputdatadir'],
                               "{patient_id}_recon_success.txt")
    params:
        brainmask_mgz = os.path.join(FS_PATIENT_OUTPUT_DIR, "mri",
                                     "brainmask.mgz")
    output:
        brainmask_nifti = os.path.join(FS_PATIENT_OUTPUT_DIR, "mri",
                                       "brainmask.nii.gz")
    shell:
        "mri_convert {params.brainmask_mgz} {output.brainmask_nifti};"

"""
Rule to map the brain mask over to the CT space.
"""
rule map_brainmask_to_ct:
    input:
        brainmask_file = os.path.join(FS_PATIENT_OUTPUT_DIR, "mri",
                                                     "brainmask.nii.gz"),
        CT_NIFTI_IMG = os.path.join(FS_PATIENT_OUTPUT_DIR, "CT",
                                                            "CT.nii"),
        # mapping matrix for post to pre in T1
        MAPPING_FILE_ORIG = os.path.join(COREGISTRATION_OUTPUT_DIR,
                                         "fsl_ct-to-t1_omat.txt"),
    output:
        # mapping matrix for post to pre in T1
        MAPPING_FILE = os.path.join(COREGISTRATION_OUTPUT_DIR,
                                    "fsl_brainmask_to_ct_omat.txt"),
        brainmask_inct_file = os.path.join(COREGISTRATION_OUTPUT_DIR,
                                                     "brainmask_inct.nii.gz"),
    shell:
        "flirt -in {input.brainmask_file} \
                            -ref {input.CT_NIFTI_IMG} \
                            -omat {output.MAPPING_FILE} \
                            -out {output.brainmask_inct_file};"
        # "applyxfm4D {input.brainmask_file} {input.CT_NIFTI_IMG} {output.brainmask_inct_file} {input.MAPPING_FILE_ORIG};"

rule map_wm_to_ct:
    input:
        wm_output_file = os.path.join(FS_PATIENT_OUTPUT_DIR, "mri",
                                      "wm.mgz"),
        CT_NIFTI_IMG = os.path.join(FS_PATIENT_OUTPUT_DIR, "CT",
                                                            "CT.nii"),
    output:
        wm_output_file_nifti  = os.path.join(FS_PATIENT_OUTPUT_DIR, "mri",
                              "wm.nii.gz"),
        # mapping matrix for post to pre in T1
        MAPPING_FILE = os.path.join(COREGISTRATION_OUTPUT_DIR,
                            "fsl_wm_to_ct_omat.txt"),
        wm_inct_outputfile = os.path.join(COREGISTRATION_OUTPUT_DIR,
                                        "wm_in_ct.nii.gz"),
        wm_inct_outputfile_nifti = os.path.join(COREGISTRATION_OUTPUT_DIR,
                                        "wm_in_ct.nii")
    shell:
        "mri_convert {input.wm_output_file} {output.wm_output_file_nifti};"
        "flirt -in {output.wm_output_file_nifti} \
                    -ref {input.CT_NIFTI_IMG} \
                    -omat {output.MAPPING_FILE} \
                    -out {output.wm_inct_outputfile};"
        "mri_convert {output.wm_inct_outputfile} {output.wm_inct_outputfile_nifti};"
# "applyxfm4D {input.wm_output_file} {input.CT_NIFTI_IMG} {output.wm_inct_outputfile} {input.MAPPING_FILE_ORIG};"

rule convert_to_mgz:
    input:
        CT_NIFTI_IMG_ORIG = os.path.join(FS_PATIENT_OUTPUT_DIR, "CT",
                                    "CT.nii"),
        PREMRI_NIFTI_IMG_ORIG = os.path.join(FS_PATIENT_OUTPUT_DIR, "mri",
                                     "T1.nii"),
    output:
        CT_NIFTI_IMG_MGZ = os.path.join(FS_PATIENT_OUTPUT_DIR, "CT",
                                    "CT.mgz"),
        PREMRI_NIFTI_IMG_MGZ = os.path.join(FS_PATIENT_OUTPUT_DIR, "mri",
                                     "preT1.mgz"),
    shell:
        "mrconvert {input.PREMRI_NIFTI_IMG_ORIG} {output.PREMRI_NIFTI_IMG_MGZ};"
        "mrconvert {input.CT_NIFTI_IMG_ORIG} {output.CT_NIFTI_IMG_MGZ};"


"""
Rule for running NDREG algorithm script using tensorflow
"""
rule ndreg_registration_ct_to_pre:
    input:
        PREMRI_NIFTI_IMG = os.path.join(FS_PATIENT_OUTPUT_DIR,
                                            "T1.nii"),
        CT_NIFTI_IMG = os.path.join(FS_PATIENT_OUTPUT_DIR,
                                             "CT.nii.gz"),
    params:
        outputdir = os.path.join(COREGISTRATION_OUTPUT_DIR),

    output:
        # mapping matrix from CT -> MRI
        LDDMM_MAPPED_FILE=os.path.join(COREGISTRATION_OUTPUT_DIR,
                                        "ndreg_ct-to-pre-t1_omat.txt"),
        # mapped image from CT -> MRI
        output_registration_image = os.path.join(COREGISTRATION_OUTPUT_DIR,
                                        "CT_in_pre_T1_ndreg.nii.gz"),
    shell:
        "python run_ndreg.py " \
                "{input.PREMRI_NIFTI_IMG} " \
                "{input.CT_NIFTI_IMG} " \
                "{output.mapping_file} " \
                "{output.output_registration_image} " \
                "{params.outputdir};"


rule convert_coordinate_system:
    input:
        raw_ct_file = os.path.join(FS_PATIENT_OUTPUT_DIR,
                                         "CT.nii.gz"),
        raw_mri_file = os.path.join(FS_PATIENT_OUTPUT_DIR,
                                          "T1.nii"),
        mgz_mri_file = os.path.join(FS_PATIENT_OUTPUT_DIR,
                                        "T1.mgz"),
        desikan_orig_file=os.path.join(FS_PATIENT_OUTPUT_DIR,
                               "aparc.a2009s+aseg.mgz"),
        destrieux_orig_file = os.path.join(FS_PATIENT_OUTPUT_DIR,
                                   "aparc.a2009s+aseg.mgz"),
        talairach_transform_file = os.path.join(FS_PATIENT_OUTPUT_DIR,
                                        "transforms/talairach.xfm"),
    output:
        ras_label_volume=os.path.join(FS_PATIENT_OUTPUT_DIR,
                                      "converted_coord_system",
                                        "label_{atlas}.RAS.nii.gz"),
        tal_label_volume = os.path.join(FS_PATIENT_OUTPUT_DIR,
                                        "converted_coord_system",
                                        "label_{atlas}.TAL.nii.gz"),
        ras_std_label_volume=os.path.join(FS_PATIENT_OUTPUT_DIR,
                                "converted_coord_system",
                                "label_{atlas}.RAS.RO.nii.gz"),
        tal_std_label_volume = os.path.join(FS_PATIENT_OUTPUT_DIR,
                                        "converted_coord_system",
                                        "label_{atlas}.TAL.RO.nii.gz"),
    run:
        if wildcards.atlas == "dk":
            shell("echo 'Running on desikan atlas!';")
            "echo 'mri_convert -rt nearest --out_orientation RAS {input.desikan_orig_file} \
                                                            {output.ras_label_volume}';"
            shell("mri_convert -rt nearest --out_orientation RAS {input.desikan_orig_file} \
                                                            {output.ras_label_volume};")
            shell("mri_convert {input.desikan_orig_file} --apply_transform {input.talairach_transform_file} -oc 0 0 0 {output.tal_label_volume};")

        elif wildcards.atlas == "destrieux":
            shell("echo 'Running on destrieux atlas!'")
            shell("mri_convert -rt nearest --out_orientation RAS {input.destrieux_orig_file} \
                                                            {output.ras_label_volume};")
            shell("mri_convert {input.destrieux_orig_file} --apply_transform {input.talairach_transform_file} -oc 0 0 0 {output.tal_label_volume};")

        shell("fslreorient2std  {output.ras_label_volume} {output.ras_std_label_volume};")
        shell("fslreorient2std {output.tal_label_volume} {output.tal_std_label_volume};")



"""
Rule for robust registration of two volumes within two volumes
"""
rule robust_registration_ct_to_pre:
    input:
        PREMRI_IMG_MGZ = os.path.join(FS_PATIENT_OUTPUT_DIR, "mri",
                                     "preT1.mgz"),
        CT_IMG_MGZ = os.path.join(FS_PATIENT_OUTPUT_DIR, "CT",
                                     "CT.mgz"),
    output:
        # mapping matrix from CT -> MRI
        output_registration_file = os.path.join(COREGISTRATION_OUTPUT_DIR,
                                                "robustfs_ct-to-t1_omat.txt"),
        # mapped image from CT -> MRI
        output_registration_image = os.path.join(COREGISTRATION_OUTPUT_DIR,
                                                 "CT_in_pre_T1_robustregistration.mgz"),
        weights_file = os.path.join(COREGISTRATION_OUTPUT_DIR,
                                                "CT_in_pre_T1_outlierweights.mgz")
    shell:
        "mri_robust_register --mov {input.CT_IMG_MGZ} \
                            --dst {input.PREMRI_IMG_MGZ} \
                            --lta {output.output_registration_file} \
                            --mapmovhdr {output.output_registration_image} \
                            -weights {output.weights_file} \
                            --satit \
                            --iscale;"

"""
Rule for running lddmm algorithm script using tensorflow
"""
rule lddmm_registration_ct_to_pre:
    input:
        PREMRI_NIFTI_IMG = os.path.join(FS_PATIENT_OUTPUT_DIR, "mri",
                                            "T1.nii"),
        CT_NIFTI_IMG = os.path.join(FS_PATIENT_OUTPUT_DIR, "CT",
                                             "CT.nii.gz"),
    output:
        # mapping matrix from CT -> MRI
        LDDMM_MAPPED_FILE=os.path.join(COREGISTRATION_OUTPUT_DIR,
                                        "ldmm_ct-to-pre-t1_omat.txt"),
        # mapped image from CT -> MRI
        output_registration_image = os.path.join(COREGISTRATION_OUTPUT_DIR,
                                        "CT_in_pre_T1_lddmm.nii.gz"),
    shell:
        "python run_lddmm_coregister.py " \
                "{input.PREMRI_NIFTI_IMG} " \
                "{input.CT_NIFTI_IMG} " \
                "{output.output_registration_image};"
